# -*- coding: utf-8 -*-
"""f_lab1_cp3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R66msY37xtxHDoNlgnLSgN0f1thQFtQ_
"""

import sys
!python -m pip install agentpy
!python -m pip install vispy
!pip install --target "/usr/lib/python3.10" pyqt5

# Model design
import agentpy as ap
import numpy as np
import scipy as sp
from numba import njit, prange
from typing import Tuple
import random

# Visualization
import matplotlib.pyplot as plt
import IPython
from vispy import app, scene
from scipy.spatial.distance import cdist
from vispy.geometry import Rect

from matplotlib import animation

@njit(parallel=True)
def normalize(v):
    """ Normalize a vector to length 1. """
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

class Boid(ap.Agent):
    """
    An agent with a position and velocity in a continuous space,
    who follows Craig Reynolds three rules of flocking behavior;
    plus a fourth rule to avoid the edges of the simulation space and fifth rule - error.
    """

    def setup(self):
        """
        Set agent base parameters:
        velocity
        condition - принадлежность группе 1 или 2 (Вариант 1)
        coef - матрица весов
        """

        self.velocity = normalize(
            self.model.nprandom.random(self.p.ndim) - 0.5)

        if random.randint(0, 1) == 1:
            self.condition = 1
        else:
            self.condition = 0

        self.coef_v1_si = random.randint(0, 3)
        self.coef_v1_di = random.randint(0, 3)
        self.coef_v2_si = random.randint(0, 3)
        self.coef_v2_di = random.randint(0, 3)
        self.coef_v3_si = random.randint(0, 3)
        self.coef_v3_di = random.randint(0, 3)
        self.coef_v4 = random.randint(0, 3)
        self.coef_v5 = random.randint(0, 3)


    def setup_pos(self, space):
        """
        Set agent positioning in space
        """

        self.space = space
        self.neighbors = space.neighbors
        self.pos = space.positions[self]

    def update_velocity(self):
        """
        updates agent behaviour every step based on the rules of flocking behaviour:
        cohesion, separation, alignment and wall and error constraints
        """

        def cohesion_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array):
            """
            function to update cohesion of an agent
            """
            if nbs_len > 0:
                center = np.sum(nbs_pos_array, 0) / nbs_len
                v1 = (center - pos) * self.p.cohesion_strength
                for ns in nbs:
                  if self.condition == ns.condition:
                    v1 *= self.coef_v1_si * ns.coef_v1_si
                  else:
                    v1 *= self.coef_v1_di * ns.coef_v1_di
            else:
                v1 = np.zeros(ndim)
            return v1

        def separation_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array):
            """
            function to update separation of agents
            """
            v2 = np.zeros(ndim)
            for nb in self.neighbors(self, distance=self.p.inner_radius):
                v2 -= nb.pos - pos
                if self.condition == nb.condition:
                    v2 *= self.coef_v2_si * nb.coef_v2_si
                else:
                    v2 *= self.coef_v2_di * nb.coef_v2_di
            v2 *= self.p.seperation_strength
            return v2

        def alignment_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array):
            """
            function to allign target agent
            """
            if nbs_len > 0:
                average_v = np.sum(nbs_vec_array, 0) / nbs_len
                v3 = (average_v - self.velocity) * self.p.alignment_strength
                for ns in nbs:
                  if self.condition == ns.condition:
                    v3 *= self.coef_v3_si * ns.coef_v3_si
                  else:
                    v3 *= self.coef_v3_di * ns.coef_v3_di
            else:
                v3 = np.zeros(ndim)
            return v3

        def wall(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array):
            """
            function responsible to set behaviour of an agent near the wall
            """
            v4 = np.zeros(ndim)
            d = self.p.border_distance
            s = self.p.border_strength
            for i in range(ndim):
                if pos[i] < d:
                    v4[i] += s
                elif pos[i] > self.space.shape[i] - d:
                    v4[i] -= s
            return v4*self.coef_v4

        def error_func(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array):
            """
            add error
            """
            v5 = np.zeros(ndim)
            return v5 + self.coef_v5

        pos = self.pos
        ndim = self.p.ndim
        nbs = self.neighbors(self, distance=self.p.outer_radius)
        nbs_len = len(nbs)
        nbs_pos_array = np.array(nbs.pos)
        nbs_vec_array = np.array(nbs.velocity)
        v1 = cohesion_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array)
        v2 = separation_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array)
        v3 = alignment_update(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array)
        v4 = wall(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array)
        v5 = error_func(self, ndim, pos, nbs, nbs_len, nbs_pos_array, nbs_vec_array)

        self.velocity += v1 + v2 + v3 + v4 + v5
        self.velocity = normalize(self.velocity)

    def update_position(self):
        """
        function to update position of an agent in space according to it's behaviour change
        """

        self.space.move_by(self, self.velocity)

class BoidsModel(ap.Model):
    """
    An agent-based model of animals' flocking behavior,
    based on Craig Reynolds' Boids Model [1]
    and Conrad Parkers' Boids Pseudocode [2].

    [1] http://www.red3d.com/cwr/boids/
    [2] http://www.vergenet.net/~conrad/boids/pseudocode.html
    """

    def setup(self):
        """ Initializes the agents and network of the model. """

        self.space = ap.Space(self, shape=[self.p.size]*self.p.ndim)
        self.space1 = ap.Space(self, shape=[self.p.size]*self.p.ndim)

        self.agents = ap.AgentList(self, self.p.population, Boid)
        self.space.add_agents(self.agents, random=True)
        self.agents.setup_pos(self.space)



    def step(self):
        """ Defines the models' events per simulation step. """

        self.agents.update_velocity()  # Adjust direction
        self.agents.update_position()  # Move into new direction

def animation_plot_single(m, ax):
    """
    set animation parameters
    """
    ndim = m.p.ndim
    qb = m.p.population
    ax.set_title(f"Boids Flocking Model {ndim}D frame={m.t} , {qb} Boids with cohesion strength 0.05, separation strength 0.5, alignment strength 0.2")



    for n in m.agents.select(m.agents.condition == 0):
        pos = m.space.positions[n]
        pos = np.array(list(pos)).T
        ax.scatter(*pos, s=1, c='black')

    for k in m.agents.select(m.agents.condition == 1):
        pos1 = m.space.positions[k]
        pos1 = np.array(list(pos1)).T
        ax.scatter(*pos1, s=1, c='red')

    ax.set_xlim(0, m.p.size)
    ax.set_ylim(0, m.p.size)

def animation_plot(m, p):
    """
    launch animation process
    """
    projection = None
    fig = plt.figure(figsize=(7,7))
    ax = fig.add_subplot(111, projection=projection)
    animations = ap.animate(m(p), fig, ax, animation_plot_single)

    FFwriter = animation.FFMpegWriter(fps=30, extra_args=['-vcodec', 'libx264'])
    animations.save('basic_animation.mp4', writer=FFwriter)

    #return IPython.display.HTML(animation.to_jshtml(fps=20))

parameters_1000_boids = {
    'size': 600,
    'seed': 123,
    'steps': 1800,
    'ndim': 2,
    'population': 1000,
    'inner_radius': 200,
    'outer_radius': 400,
    'border_distance': 10,
    'cohesion_strength': 0.05,
    'seperation_strength': 0.5,
    'alignment_strength': 0.2,
    'border_strength': 0.7
}

parameters_5000_boids = {
    'size': 2000,
    'seed': 123,
    'steps': 50,
    'ndim': 2,
    'population': 5000,
    'inner_radius': 500,
    'outer_radius': 1500,
    'border_distance': 10,
    'cohesion_strength': 0.05,
    'seperation_strength': 0.5,
    'alignment_strength': 0.2,
    'border_strength': 0.7
}

animation_plot(BoidsModel, parameters_1000_boids) #результат представляет собой видео с необходимыми заданными параметрами.
#Запись была протестированна на более маленьких моделей через инструменты записи экрана macOS. Запись данного видео отдельным файлом выходила за рамки времени, отведенного на сдачу
#программы в classroom

animation_plot(BoidsModel, parameters_5000_boids)  #результат представляет собой видео с необходимыми заданными параметрами.
#Запись была протестированна на более маленьких моделей через инструменты записи экрана macOS. Запись данного видео отдельным файлом выходила за рамки времени, отведенного на сдачу
#программы в classroom